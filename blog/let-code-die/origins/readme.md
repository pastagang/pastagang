[pastagang blog](/blog)

# Origins of "Let code die" 

"let code die" is a recurring mantra that the [pastagang](https://pastagang.cc) group has picked up and run with

<br>

<br>

## Origins

"let code die" can be traced back to three different computing movements: 

- [robust first computing](https://andrewwalpole.com/blog/an-introduction-to-robust-first-computation/)
- [permacomputing](https://permacomputing.net/permacomputing/)
- [local first computing](https://www.inkandswitch.com/local-first/)

i wanted to participate in all three movements at the same time so i tried to figure out what they all have in common. and my idea was that they all acknowledge that code can break and die in various ways, and that we should plan around that.

in my opinion, the three movements don't say that code death is something to be avoided, but rather that it is something to be handled gracefully.

you see, Software is a sort of executable knowledge, and just like unstable particles decaying over time, [knowledge has a half-life too]([url](https://en.wikipedia.org/wiki/Half-life_of_knowledge))!

Should we [kill code with fire](https://www.goodreads.com/en/book/show/54716655-kill-it-with-fire)?

I don't know. is killing it with fire the most graceful thing to do?

(maybe)

<br>

Let's look at what the three movements say: 

### robust first computing

todo

### permacomputing
  
permacomputing often looks to ways of getting around code death, such as using specifications to resurrect dead code. Devine Lu Linvega gives an example of this in their [strange loop talk](https://youtu.be/T3u7bGgVspM?si=NYSt_WU8hqxmru9J), and they explain how some of the software they're building is intended to be easily resurrectable. this same idea appears in [cold-blooded software](https://dubroy.com/blog/cold-blooded-software/), a blog post that explicitly talks about bringing software back to life. 

### local first computing

Local first computing proposes a set of principles and ideas for software that resonates with the *let code die* philosophy. It acknowledges that software services and cloud providers will inevitably become inaccessible. Instead of fighting this thought, local first  embraces this nature of software by ensuring that the user's data survives irrespective of any particular service or implementation. When code dies in a local first environment, the data remains alive, ready to be reused with new code. This turns code death into a natural part of the software lifecycle. 

<br>

<hr>

<br>

why do we try to maintain projects that are old and should be deprecated? most such projects have newer alternatives that are more secure, more functional, and better suited for the modern world, yet we keep using things like email, pgp, x11, etc etc

this software will die. maybe not within the decade, our or lifetimes, but it will pass on. adobe flash died, and now there's [new code](https://ruffle.rs/) to reuse old flash files. who's to say this couldn't happen to something more vital, like web browsers?

i guess the problem is that we rely on heaps and heaps and stacks and stacks of technology. we can't and probably don't want to get rid of all of it. but where we can and where is reasonable, i think it's nice to not rely on specific pieces of technology. i don't think that's too crazy an idea

## tadi web

todo

[https://tadiweb.com](https://tadiweb.com)

## embrace death

todo

[Death of the tadi web presentation (youtube)](https://www.youtube.com/watch?v=ft6xOAijwFo)

## let code die

todo

<br>

a blog post by [pastagang](/)
